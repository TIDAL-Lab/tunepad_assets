import { Note } from "./note";
import { SynthPatchRef } from "./synth";
/**
 * A Trace object is generated by the python compiler and represents a list of
 * audio events that generate music.
 * Traces are immutable.
 */
export declare class MusicTrace {
    private trace;
    [Symbol.iterator](): Iterator<TraceEvent>;
    get length(): number;
    get isEmpty(): boolean;
    private _beats;
    get beats(): number;
    private _playhead;
    private _minNote;
    get minNote(): number;
    get minOctave(): number;
    private _maxNote;
    get maxNote(): number;
    get maxOctave(): number;
    get noteRange(): number;
    get octaveRange(): number;
    private _noteCount;
    get noteCount(): number;
    /** set of voice IDs in the trace */
    readonly voices: Set<number>;
    get messages(): TraceEvent[];
    get warnings(): TraceEvent[];
    get unitTests(): TraceEvent[];
    get passes(): TraceEvent[];
    get fails(): TraceEvent[];
    /** apply a custom filter to the trace list */
    filter(f: (e: TraceEvent) => boolean): MusicTrace;
    /** apply a custom sort to the trace list */
    sort(f: (a: TraceEvent, b: TraceEvent) => number): this;
    /** Return all events that intersect with a given playhead position */
    slice(playhead: number): TraceEvent[];
    readonly patch?: SynthPatchRef;
    /** Creates an empty trace */
    constructor(patch?: SynthPatchRef);
    /** Create an empty trace */
    static emptyTrace(patch?: SynthPatchRef): MusicTrace;
    /** Create a trace from python compiler output */
    static fromPython(list: Array<Map<string, any>>, patch?: SynthPatchRef): MusicTrace;
    /** Clone the trace, possibly with a new synth patch */
    static fromTrace(other: MusicTrace | TraceEvent[], patch?: SynthPatchRef): MusicTrace;
    /** Join two traces together */
    join(other: MusicTrace | TraceEvent[]): MusicTrace;
    /**
     * Return a new trace will all events that have onsets greater than or equal to `start`
     * and less than `end`. Both parameters are beat values.
     */
    subtrace(start: number, end: number): MusicTrace;
    /**
     * Return a new trace with events of only the given types
     */
    ofType(commands: string[]): MusicTrace;
    /**
     * Compare two trace objects to see if they are equivalent except for line numbers
     */
    isEquivalent(other: MusicTrace): boolean;
    private addTraceEvent;
    /**
     * Return a list of events for the given trace group number
     */
    getTraceGroup(bug: number): Array<TraceEvent>;
}
/**
 * Audio trace of a program's execution. Trace events are generated by
 * python and then replayed to generate sounds and animation.
 */
export declare class TraceEvent {
    static readonly PLAY = "play";
    static readonly SOUND = "sound";
    static readonly REST = "rest";
    static readonly PUSH_FX = "push_fx";
    static readonly POP_FX = "pop_fx";
    static readonly MESSAGE = "message";
    private static _TRACE_ID;
    readonly id: number;
    readonly command: string;
    readonly time: number;
    duration: number;
    get end(): number;
    line: number;
    note: Note;
    trace_group: number;
    voice: number;
    params: Map<string, any>;
    constructor(command: string, time: number, id?: number);
    clone(): TraceEvent;
    static fromMap(m: Map<string, any>): TraceEvent;
    /**
     * Are two trace events the same except for their line numbers
     */
    isEquivalent(other: TraceEvent): boolean;
}
